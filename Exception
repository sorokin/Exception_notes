Exception:
В ходе написания программ, часто возникают случаи, когда нам приходится отвлекаться от написания основной логики. Нам нужно учитывать граничные случаи и ошибки, которые могут возникнуть как во внутреннем коде нашей программы, так и во внешнем коде. Это может быть: нехватка динамической памяти, неправильный ввод пользователя, ошибка с файловой системой и т. д.
Все это приходится продумывать, и иногда это может сильно увеличить количество кода и время его написания. Чтобы упростить обработку таких случаев существует паттерн исключений.

Исключение - это ситуация, которую МЫ сочли исключительной, и которую хотим отделить от основной логики программы. Естественно код обработки исключения мы тоже должны написать сами. Но компилятор помогает нам, генерировать дополнительную информации об исключении, отслеживать и подбирать необходимый код обработки в зависимости от исключения.

Пусть мы пишем функцию деления.
void div(int a, int b) {
	return a / b;
}

Пусть исключительная ситуация возникает тогда, когда b = 0. И мы хотим сообщить об этом пользователю нашей функции.

class Division_by_zero() {
	int dividend
	string message;
	Division_by_zero(int &dividend, string const &message) :
		dividend(dividend), message(message) { }
};
мы объявили класс, объекты которого будут хранить в себе всю информации об исключении. Тип класса-исключения называется просто типом исключения.

void div(int a, int b) {
	if (b == 0) // возникает исключительное состояние
		throw Division_by_zero(b, "in function div(int, int)"); // генерируем исключение.
	return a / b;
}
Если возникает ситуация, когда нам передали в качестве делителя ноль, то мы создаем/генерируем/возбуждаем исключение. Это значит, что дальше не будет исполняться основная логика программы, пока не будет обработано исключение.

А так пользователь может обрабатывать исключение:
int main() {
	int n;
	cin >> n;
	try { // здесь указываем опрераторы, в которых мы хотим ловить исключения.
		for (int i = 0, a, b; i < n; ++i) {
			cin >> a >> b;
			cout << div(a, b);
		}
	} catch(Division_by_zero obj) { //здесь указываем тип исключения, которое мы хотим обработать
		// здесь обрабатываем исключение
		cout << obj.dividend << "by 0 " << obj.message();
	}
}
Как только возникает попытка деления на ноль. генерируется исключение, в коде div(int, int) оно не обрабатывается, поэтому выбрасывается во внешний код, где мы его ловим и выводим сообщение об ошибке.

Если исключения не возникает, то код отработает нужным образом: мы выведем результаты всех делений.

Теперь рассмотрим используемые здесь конструкции подробнее:

try{} -- защищенный блок. Здесь мы пишем код, в котором мы хотим ловить и обрабатывать исключения.
catch(){} -- блок перехвата исключений или блок обработки или обработчик. Здесь буду ловиться исключения, тип которых совпадает по определенным правилам с типом указанным в (), и обрабатывать инструкциями в {}
throw -- оператор инициализации исключения. Он генерирует исключение. (Обычно говорят, "бросает" или "выбрасывает" исключение)

Теперь давай рассмотрим детали работы этого механизма.

блок try-catch - реализует обработку исключений. И имеет общий вид:
try {операторы защищенного блока}
// catch-блоки
catch() {обработчик}
...
catch() {обработчик}
То есть обработчиков может быть несколько, каждый обрабатывает свой тип исключений.

общий вид catch-блока:
	1) catch(Type) {обработчик исключения } // мы не используем генерируемый исключением объект.
	2) catch(/*declaration exception_variable*/) { обработчик исключения }
	3) catch(...) {обработчик исключения} // мы ловим исключение с любым типом объекта

Что происходит, когда мы генерируем исключение:
1) Создается копия объекта переданного в оператор throw. Этот объект будет существовать до тех пор, пока исключение не будет обработано. Если тип объекта имеет конструктор копирования, то он будет вызван.
2) Прерывается выполнение защищенного try-блока.
3) Выполняется раскрутка стека, пока исключение не будет обработано.

При раскрутке стека, вызываются деструкторы локальных переменных в обратном порядке их объявления. При разрушении всех локальных объектов текущей функции процесс продолжается в вызывающей функции. Раскрутка стека продолжается пока не будет найдем try...catch-блок. При нахождении try...catch-блока, проверяется, может ли исключение быть поймано одним их catch-блоков.

Catch-блоки проверяются в том порядке, в котором написаны. По следующим критериям:
1) если тип, указанный в catch-блоке, совпадает с типом исключения или является ссылкой на этот тип.
2) класс, заданный в catch-блоке, является предком класса, заданного в throw, и наследование открытое (public).
3) указатель, заданный в операторе throw, может быть преобразован по стандартным правилам к указателю, заданному в catch-блоке.
4) в catch-блоке указанно многоточие

Если найдет нужный catch-блок, то выполняется его код, остальные catch-блоки игнорируются, а выполнение продолжается после try...catch-блока и исключение считается обработанным. Если ни один catch-блок не подошел, процесс раскрутки стека продолжается.

NB) Так как поиск ведется последовательно, то нужно учитывать порядок catch-блоков (Например, catch(...) должен быть последним).

В некоторых случаях внутри catch-блока может быть необходимо не завершать раскрутку стека. Для этого существует специальная форма оператора throw без аргумента. Она означает проброс текущего исключения. Исключение все еще считается не обработанным.

//NB
при это следует заметить, что при повторном выбросе исключения рассматривается не параметр текущего catch-блока, а именно изначальный статический объект. Именно он скопируется в качестве параметра в следующий обработчик. Поэтому его этот статический объект живет пока его исключение не обработается полностью. Поэтому при приведении тип исключения не теряется.

class Exception {
public:
	Exception(): value(0) { }
	int value;
};

void third() {
	throw Exception();
	std::cout << "end third\n";
}

void second() {
	try {
		third();
	}
	catch (Exception exc) {
		std::cout << "in second Exception-value = " << exc.value << std::endl;
		exc.value = 100;
		throw;
	}
	std::cout << "end second\n";
}

void first() {
	try {
		second();
	}
	catch (Exception exc) {
		std::cout << "in first Exception-value = " << exc.value << std::endl;
	}
	std::cout << "end first\n";
}

int main() {
	first();
	std::cout << "end main\n";
	return 0;
}

Вывод программы:
in second Exception-value = 0
in frist Exception-value = 0
end first
end main

Таже при наследовании классов исключений следует различать catch(type obj) и catch(type& obj). В первом случае при входе в catch блок делается копия объекта-исключения. Во втором случае obj лишь ссылается на этот объект и копии не создается.

Пример:
struct Exception_base {
    virtual char const* msg() const {
        return "base";
    }
};

struct Exception_derived : Exception_base {
    virtual char const* msg() const {
        return "derived";
    }
};

int f() {
    try {
        throw derived();
    }
    catch (base e) {
        std::cout << e.msg() << std::endl;
    }
}

int g() {
    try {
        throw derived();
    }
    catch (base const& e) {
        std::cout << e.msg() << std::endl;
    }
}

В данном примере g() выводит "derived", а функция f() выводит "base", поскольку объект исключения был скопирован с базы объекта, который мы передали в оператор throw и новая копия имеет тип base.

Функциональные try-блоки:

Часто мы хотим, чтобы все тело функции находилось в try-блоке. Тогда это try-блок называется функциональным. И для него есть отдельный синтаксис.
int main() try {
	//main's body
}
catch (...) { }

Здесь функциональные try-блоки являются синтаксическим сахаром, но есть ситуации когда без них не обойтись: обработка исключений в конструкторе.

Вот есть класс, котором мы хотим ловить и обрабатывать исключения.
class St {
public:
	St(): member() {
		try {
		 // Constructor's code
		}
		catch (...) { }
	}
private:
	Member_type member;
}

Но заметим, что вызов конструкторов мемберов не находится внутри try-блока и исключения возникшие в их конструкторах не поймаются.
Поэтому мы используем здесь функциональный try-блок:
class St {
public:
	St() try: member() {
		 // Constructor's code
		}
		catch (...) {

		} // implicit throw
	}
private:
	Member_type member;
}
//NB
Но у функциональный try-блок в конструкторах, есть особенность: они всегда бросают исключение повторно.

Уничтожение объекта при исключении в конструкторе.

Также важно помнить, что если в конструкторе происходит исключение, то для него не вызовется деструктор, так объект еще не считается созданным.

2) Best practice
Часто исключений применяются для корректной работы с ресурсами. То есть если возникает исключение и владеем какими-то ресурсам, то в случае генерации исключения следует их освободить.

Например, мы пишем вектор, и мы хотим скопировать данные в другой участок памяти, чтобы скопировать вектор. При этом если во время копирование какого-то объекта возникнет исключение, то хорошо если уже созданные объекты будут разрушены.
template <typename T>
void copy_construct(T* dist, T const * sourse, size_t size) {
	size_t i = 0;
	try {
		for (; i != size; ++i) {
			new (dist + i) T(sourse[i]);
		}
	}
	catch (...) { // если ошибка при копировании
		for (size_t j = i; j != 0; --j) {
			dist[j - 1].~T(); // вызовем деструкторы созданных объектов
		}
		throw;
	}
}

Полезно знать про стандартные исключения, которые также связанны наследованием.
|) std::ecxeption
|   |   |
v   v   v
||) std::bad_alloc, std::bad_cast, std::bad_typeid и т. д.

Подробнее можно почитать здесь: "https://www.tutorialspoint.com/cplusplus/cpp_exceptions_handling.htm"
"http://en.cppreference.com/w/cpp/error/exception"

//NB
Хорошим тоном является наследование от std::exception

Когда мы организовываем исключения в иерархии классов, то получаем мощный механизм описания исключение и способов их обработки. Создав такую структуры мы можем обрабатывать как более общие ошибки, так и более специализированные.
Пример:
	class StackException {};
	class popOnEmpty(): public StackException {};
	class pushOnFull(): public StackException {};

	Причем сгенерировав исключение типа popOnEmpty()
	Мы можем в разных обработчиках независимо выбирать: обработать как popOnEmpty или как StackException, так как тип исключения не теряется при повторной генерации этого исключения.

Bad practice:
1) Писать код бросающий исключения в catch-блоке. Это не всегда бывает просто.
2)  Хотя если исключений не происходит, то по скорости выполнения программа не сильно упадет, но иногда нужно учитывать большой оверхед в случае возникновения и обработки исключения.

Функция std::terminate().

Это функция, которая вызывается если у механизма исключений не получается корректно отработать, чтобы завершить программу.
Случаи когда она вызывается:
1) Исключение брошено и не поймано ни одним catch-блоком, то есть пробрасывается вне main().
2) Исключение бросается во время обработки другого исключения. Это может произойти только в catch-блоке или деструкторе. А также в функциях, которые вызываются ими.
3) Если функция переданная в std::atexit и std::at_quick_exit бросит исключение.
4) Если функция нарушит гарантии noexcept specification. Например, если функция помеченная как noexcept бросит исключение.
5) При подобных и не только ошибках в потоках.

По умолчанию std::terminate() вызвает std::abort(), но можно это изменить, написав свою функцию my_terminate() и зарегистрировать ее как терминальную.
void my_terminate() {
	cout << "It's not a bug, it's a feature!";
}
/**/
set_terminate(my_teminate);
