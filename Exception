План:
1) основы механизма
2) тонкости использования
3) Практика: Зачем это все собственно нужно?
---------------------------------------------------------------------------------------
1) основы механизма

В ходе работы программы часто могут возникнуть ситуации, которые не вписываются в общий алгоритм, или которые просто не отражают саму логику программы, но их тоже приходиться учитывать. Это, например, нехватка памяти, неправильный вывод пользователя, ошибка работы с ресурсами и т. д. С другой стороны, четко определить, что стоит отделять от основной логики сложно. Поэтому дадим пока довольно общие определения, а как этим пользоваться на практике мы обсудим отдельно.

Исключение - это ситуация, которую МЫ сочли исключительной. Эти ситуации мы будет обрабатывать как-то особенно(отдельно от основной логики). Теперь нам нужно научиться выявлять, отслеживать и обрабатывать их.

Пусть мы пишем функцию, которая принимает три числа кладет в первое результат деления второго на третие.
void div(int &res, int a, int b) {
	res = a / b;
}

Пусть исключительно ситуация возникает тогда, когда b = 0. И мы хотим обработать это исключение так: положить в res просто значение a.

void div(int &res, int a, int b) {
	try {
		if (b == 0)
			throw b; // генерируем исключение
 // если исключения нет, то код работает в обычном режиме
		res = a / b;
	}
	catch(int a) { // ловим исключение
		res = a; // обрабатываем исключение
	}
}
NB) типом исключения называется тип объекта, которым передаем в throw. Тип исключения должен ясно описывать ситуацию, так как по типу выбирается обработчик.

Теперь рассмотрим используемы здесь конструкции:

try{} -- защищенный блок. Здесь мы пишем код, в которым будут ловиться исключения.
catch(){} -- блок перехвата исключений. Здесь буду ловиться исключения указанные в (), и обрабатывать инструкциями в {}
throw -- оператор инициализации исключения. Он генерирует исключение. (Обычно говорят, "бросает" или "выбрасывает" исключение)

блок try-catch - реализует обработку исключений. И имеет общий вид:
try {операторы защищенного блока}
// catch-блоки
catch() {обработчик}
...
catch() {обработчик}

Давайте еще раз как, это работает: если нет исключения, то все работает как обычно и catch-блоки не выполняются. Если происходит выброс исключения. Создается объект типа int со значением b, потом происходит выбор нужного обработчика, по типу этого объекта. Когда он нашелся, то выполняется соответствующий код обработки.

Теперь более подробно рассмотрим этот механизм:

общий вид catch-блока:
1) catch(Type) {обработчик исключения } // мы не используем генерируемый исключением объект.
2) catch(Type exception_variable) { обработчик исключения }
3) catch(...) {обработчик исключения} // мы ловим исключение с любым типом объекта

Что происходит когда мы генерируем исключение:
1) Создается статическая переменная со значением, заданным в операторе я throw. Она будет существовать до тех пор, пока исключение не будет обработано. Если переменная является объектом класса, то при создании вызовется конструктор копирования.
2) Прерывается выполнение защищенного try-блока(вызываются деструкторы временных объектов).
3) Выполняется поиск первого подходящего catch-блока

Как происходит поиск catch-блока:
Блоки рассматриваются в том порядке, в котором они указанны. По следующем критериям:
1) если тип, указанный в catch-блоке, совпадает с типом исключения или является ссылкой на этот тип.
2) класс, заданный в catch-блоке, является предком класса, заданного в throw, и наследование открытое (public).
3) указатель, заданый в операторе throw, может быть преобразован по стандартным правилам к указателю, заданному в catch-блоке.
4) в catch-блоке указанно многоточие

Если найдет нужный блок обработки, то выполняется его код, а остальные catch-блоки игнорируются.

NB) Так как поиск ведется последовательно, то нужно учитывать порядок catch-блоков (Например, catch(...) должен быть последним).

Если ни один catch-блок не подошел, то исключение не обработано, и поиск продолжается во внешнем коде (внешний блок или вызывающая функция).

Если пройдя по цепочке вызовов функции мы не нашли ни одного подходящего обработчика, то вызывается функция terminate(), которая вызывает abort().
NB) таком случае единственное, что мы модем сделать это написать свою функцию terminate() и зарегистрировать ее с помощью set_terminate.
Пример:
void my_terminate() { cout << "It's not a bug, it's a feature!"}
set_terminate(my_teminate);

Так же мы можем после обработки исключение в конце catch-блока написать оператор throw без параметров, тогда исключение считается обработанным не до конца. И происходит повторный выброс исключения: по статическому объекту исключения ищется еще один обработчик, который лежит выше по цепочке вызовов.
NB) при это следует заметить, что при повторном выбросе исключения рассматривается не параметр текущего catch-блока, а именно изначальный статический объект. Именно он скопируется в качестве параметра в следующий обработчик. Поэтому его этот статический объект живет пока его исключение не обработается полностью.
NB NB) Поэтому при приведении тип исключения не теряется.

Пусть мы бросили исключение Exception_heir, которое наследуется от Exception_base.
Следует различать catch(Exception_base exc) и  сatch(Exception_base &exc)
В первом случае exc -- это копия базовой части статического объекта типа Exception_heir.
А во втором сработает динамическое связывание, и мы может использовать виртуальные функции, чего не произойдет в первом случае, не смотря на идентичность статических типов exc.

Еще одним интересным моментом являются try-блоки в конструкторе. Конструктор - это очень важная часть класса, поэтому возможно ситуация, когда мы хотим обработать все исключения в нем. Наверно мы напишем так:
class St {
public:
	St(): member() {
		try {
		 // Constructor's code
		}
		{catchs}
	}
private:
	Member_type member;
}
Но заметим, что инициализация мемберов не находится внутри try-блока и не исключения возникшие в их конструкторах не поймаются. На самом деле тут есть особый синтаксис:
class St {
public:
	St() try: member() {
		 {
		 // Constructor's code
		}
		{catchs}
	}
private:
	Member_type member;
}

NB) Это называется функциональные try-блоки, то есть те, которые оборачивают все тело функции. Они есть и для обычных функций.
int main() try {
	//some code
}
{catchs}
///////////////////NOTE///////////////////////////////
У меня здесь почему-то не заработало, вот код:
#include <iostream>

class St {
public:
    St(int a, int b, int c) try: a(a), b(b), c(c) {
        throw 1;
    }
	catch(...) {
        std::cout << "error!";
    }
private:
    int a, b, c;
};

int main () {
    St a(1, 2, 3);
    return 0;
}
выводится строка "error!", но после этого дамп по памяти.
///////////////////NOTE///////////////////////////////

Также важно помнить, что если в конструкторе происходит исключение, то для него не вызовется деструктор, так объект еще не считается созданным.

NB) При генерации исключения параметр throw копируется в статическую переменную того же типа, что и СТАТИЧЕСКИЙ тип параметр. То есть такой код работать не бдует:

try {
	Exception_base *exc = new Exception_heir();
	throw exc;
} catch (Exception_heir *exc) {
	//some code
}

2) Best practice

Теперь, когда мы разобрались как работает механизм исключений, не плохо понять когда и где его лучше использовать.

Я опишу несколько ситуаций, которые покажут плохие и хорошие стороны исключений, и постараюсь подвести итог в конце.

Минусы:
1) Иногда бывает сложно понять, где происходит исключение и как его следует обработать. Эти ситуации возникают, когда нам приходится обрабатывать исключения, приходящие нам от внешнего кода.

 Во-первых без документации невозможно понять какие функции бросают исключения и какого типа.

 Во-вторых когда, мы узнаем тип исключения и какая функция его бросает, не всегда по типу исключения очевидно, как его следует обработать.

 real story: Бывает, что вы используете библиотеку с закрытым исходным кодом. И неожиданно одна из функции библиотеки кидает нам исключения типа int. И как его следует обработать ? :(

2) Не всегда мы знаем, как нужно обрабатывать ошибки, поэтому иногда больший смысл имеет просто логировать ошибки и просто продолжать исполнение кода, игнорируя ошибку. Это можно сделать catch(...), но если в нашем коде это распространенная ситуация, то механизм исключений избыточен.

Плюсы:
Исключения нужны там, где мы хотим, чтобы программа всегда работала корректно.
1) Например, мы увеличиваем вектор, и если у нас кончилась память для resize, то программа не падает и не убивает те данные, которые уже лежат в векторе.
2) Это механизм очень удобный, когда мы организовываем исключения в иерархии классов. Создав такую структуры мы при обработке, может обрабатывать как более общие ошибки, так и более специализированные.
Пример:
class StackException {};
class popOnEmpty(): public StackException {};
class pushOnFull(): public StackException {};

Причем сгенерировав исключение типа popOnEmpty()
Мы можем в разных обработчиках независимо выбирать: обработать как popOnEmpty или как StackException, так как тип исключения не теряется при повторной генерации этого исключения.

3)Полезно знать про стандартные исключения, которые также связанны наследованием.
|) std::ecxeption
	|      |
	v      v
||) std::bad_alloc, std::bad_cast, std::bad_typeid и т. д.

Подробнее можно почитать здесь: https://www.tutorialspoint.com/cplusplus/cpp_exceptions_handling.htm
http://en.cppreference.com/w/cpp/error/exception

4) Хорошим тоном является наследование от std::exception
