Exception safety

Механизм исключений является довольно мощным инструментом. Но при этом не редко возникает проблемы с его читаемостью. Далеко не всегда очевидно откуда пришло исключение и как стоит его обрабатывать. Некоторые программисты сравнивают эффект вызова исключений с эффектами от вызова goto.

Поэтому относительно работы исключений с объектами существуют Гарантии безопасности исключений (Exception safety).  Это ряд уровней безопасности, которые присваиваются методам класса. Они декларируют выполнение некоторого контракта относительно состояния объекта после выполнения операций над ним.

Уровни гарантий:

1) "No guarantees" - нет ни каких гарантий. После выполнения метода объект и данные в нем могут быть в любом состоянии. Предполагается, что объект больше не будет использоваться.
2) "Basic guarantees" - Гарантируется, что инварианты класса сохраняются и не происходит утечек памяти или других ресурсов.
3) "Strong guarantees" - Включает в себя базовую гарантию. А также требует, что в случае исключения объект остается в том, состоянии, в котором он был до выполнения операции. То есть либо операция прошла успешно, или она не повлияла на объект.
3) "Nothrow guarantees" - Кроме базовой гарантии, гарантируется, что исключения не возникают.

Теперь давайте рассмотрим важные моменты:

1) Методы пользовательского интерфейса должны удовлетворять базовым или строгим гарантиям. Это избавляет пользователей от утечек памяти и инвалидных объектов.

2) Также важно, чтобы деструктор не пробросал исключений, иначе утечки неизбежны. Например, может возникнуть исключение и при очистки стека, возникает еще одно.

3) Гарантия nothrow:

Она есть у очень небольшого количества функции: swap, vector::pop_back, операции с итераторами, Это гарантия очень важна, так как с ее помощью достигается строгая гарантия, когда мы производим необходимы операции на временном объекте, а потом просто делаем с ним swap.

NB) Спецификатор noexcept (C++11) указывает компилятору, что выполняется гарантия nothrow. Это важно, для выбора конструктора копирования: перемещающего или нет, так как при перемещении бывает сложно обработать исключение.
Подробнее в статье про перемещение.

Примеры нарушения базовой гарантии:
Главным способом предотвращением утечек памяти и других ресурсов является идиома RAII-классов (об этом подробнее ниже).

 Offtops:

1) Можно попросить оператор new не кидать исключение с помощью константы std::nothrow

2) Можно указать какие исключение может кидать функция:
void f() throw(int, double)*
*что здесь можно написать:
1) throw() - функция не кидает исключения
2) throw(T1, T2, T3) - функция может кидать исключения T1, T2, T3
3) throw(...) - функция может кидать любые исключения
Это не используется в c++11, так как возникли какие-то проблемы, и по факту полезным оказался только throw().

RAII-class:
Основы:
"Resource Acquision is Initialozation" или "Захват ресурса - это инициализация"- это идиома класса, который инкапсулирует управление каким-то ресурсом. Она значит, что объект этого класса, получает доступ к ресурсу и удерживает его в течении своей жизни, а потом этот ресурс высвобождается.
В конструкторе он должен захватить ресурс(открыть файл, выделить файл и т. д.), а в десткрукторе освободить его(закрыть файл, освободить память и т. д.).

Также важно подумать, что должно происходить при копировании объекта, часто мы просто явно запрещаем это делать.

Что это дает?
1) Удобство кода: нам не приходится каждый раз в конце тела функции освобождать ресурсы. Мы просто заводим локальную переменную. И когда выполнение текущего блока будет завершено, локальные объекты RAII-классов удалятся и ресурсы освободятся автоматически.
2) Безопасность исключений: Если вызывается исключение, то нам гарантируется, что стек очиститься и все локальные объекты удаляться, а значит и освободятся ресурсы. Без RAII приходится в ручную освобождать все ресурсы. Причем нужно учитывать какие ресурсы успели захватить до исключения, а какие нет.
3) Часто важно освобождать ресурсы в обратном порядке, относительно того, как они были захвачены. Как раз раскрутка стека при удалении локальных объектов, это поддерживает.

NB) Это идиома работает не только в С++, а любом языке с предсказуемым временем жизни объектов.

Вот не большой пример RAII-класса, который будет управлять файлом.
Ресурсом является данные типа FILE (формат файла в Си).

class File {
public:
    File(char const *filename, char const *mode)
        : _file(fopen(filename, mode)) { } //захват ресурса

    ~File() {
        fclose(_file); // освобождение ресурса
    }

    File(File const &) = delete;
    File operator=(File const &) = delete;

private:
    FILE *_file;
}

NB) Хорошой пример RAII-классов - это smart pointers, которые часто позволяют упростить безопасное управление памятью.

Тонкие моменты в RAII:

1) Необрабатываемые исключения
Вот код:

int main {
    File("input.txt", "r");
    // здесь происходит исключение
    return 0;
}

Что не так?
Проблема в том, что не смотря на то, что мы использовали RAII-класс, ресурс не будет освобожден, так как удаление локальных файлов, гарантируется, только при перехвате исключения, иначе поведение зависит от реализации.
Поэтому main следует написать так:
int main() {
    try {
        File("input.txt", "r");
        // здесь происходит исключение
    }
    catch(...) {
        cerr << "Unexpected exception.\n";
    }
}
Теперь все ок.

2) Исключение в деструкторе. Но это проблема сама по себе.

3) Исключения в конструкторах.

Вернемся к предыдущему примеру File.
Пусть в конструкторе есть код, который может сгенерить исключение, тогда возникает проблема освобождения ресурса.
File::File(char const *filename, char const *mode)
    : _file(fopen(filename, mode)) {
        //код допускающий исключение
    }
Если в теле конструктора происходит исключение, то деструктор не вызовется, так как объект не считается созданным. Что делать?

Решение № 1
Написать try-catch
class File {
public:
    File(char const *filename, char const *mode)
    try
        : _file(fopen(filename, mode)) {
        //код допускающий исключение
    }
    catch (...) {
        destruct_obj();
    }

    ~File() {
        destruct_obj();
    }

private:
    void destruct_obj() {
        fclose(_file);
    }

    FILE * _file;
};
Минусы решения: можно лучше.
Решение № 2
Можно сделать отдельный подкласс, который хранит в себе ресурс.
class File {
    struct FileHandle {
        FileHandle(FILE *fh)
            : _fh(fh) { }

        ~FileHandle() {
            fclose(_fh);
        }

        FILE *_fh;
    }

public:
    File(char const * filename, char const * mode)
        : _file(fopen(filename, mode)) {
        // код допускающий исключения
    }

    ~File() = default;

private:
    FileHandle _file;
};
Теперь все тоже ок, так как при возникновении исключения, вызовутся деструкторы от все мемберов.
Минусы решения: можно еще лучше
Решение № 3 (Изящное)
Делегирующий конструктор.
class File
{
    File(FILE * file)
        : _file(file) { }

public:
    File(char const * filename, char const * mode)
        : File(fopen(filename, mode)) {
        // код допускающий исключения
    }

    ~File() {
        fclose(_file);
    }

private:
    FILE *_file;
};
Дело в том, что если мы в конструкторе вызываем другой конструктор, то после его выполнения объект считается созданным и уничтожится в нужное время.
