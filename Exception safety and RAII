Exception safety

Пример: функция vector::resize();

template<typename T>
void vector<T>::resize(size_t size) {
    if (size > curr_size) {
        cnt_add = size - curr_size; // количество элементов для добавления.
        for (size_t i = 0; i < cnt_add; ++i) {
            push_back(T());
        }
    }
}

Это код не использует исключения, то есть не вызывает их и не обрабатывает. Но если будет ошибка выделения памяти при расширении вектора, то исключение возникнет в функции push_back(), потом пробросятся через resize() наружу.

То есть проблема в том, что мы не используя механизм исключений все равно можем получить от него проблемы. Как например, не пойманное исключение.

Поэтому существуют Гарантии безопасности исключений (Exception safety). Это некий контракт исключений, который представляет из себя ряд уровней безопасности, которые присваиваются всем методам класса. Они декларируют выполнение некоторого контракта относительно состояния объекта после выполнения операций над ним.

Уровни гарантий:

1) "No guarantees" - нет ни каких гарантий. После выполнения метода объект и данные в нем могут быть в любом состоянии. Предполагается, что продолжать работу программы нельзя.
2) "Basic guarantees" - Гарантируется, что инварианты класса сохраняются и не происходит утечек памяти или других ресурсов.
3) "Strong guarantees" - Включает в себя базовую гарантию. А также требует, что в случае исключения объект остается в том, состоянии, в котором он был до выполнения операции. То есть либо операция прошла успешно, или она не повлияла на объект.
3) "Nothrow guarantees" - Кроме базовой гарантии, гарантируется, что исключения не возникают.


Теперь давайте рассмотрим важные моменты:
1) Методы пользовательского интерфейса должны удовлетворять базовым или строгим гарантиям. Это избавляет пользователей от утечек памяти и инвалидных данных.

2) Также важно, чтобы деструктор не пробросал исключений, иначе утечки неизбежны. Например, может возникнуть исключение и при очистки стека, возникает еще одно.

3) Важность гарантии nothrow:
Она есть у очень небольшого количества функции: swap, vector::pop_back, операции с итераторами, Это гарантия очень важна, так как с ее помощью достигается строгая гарантия, когда мы производим необходимы операции на временном объекте, а потом просто делаем с ним swap.

Пример:
template <typename T>
vector<T>& vector<T>::operator=(vector const& other) {
    return this->swap(vector(other)); // swap trick!
}
мы копируем other во временный объект vector(other), а потом делаем swap с ним. Если произойдет исключение при копировании other во временный объект, то оно пробросится к нам. swap() не выполнится и исключение проброситься дальше. Наш объект не поменяется.

NB) Спецификатор noexcept (C++11) указывает компилятору, что выполняется гарантия nothrow. Это важно, для выбора конструктора копирования: перемещающего или нет, так как при перемещении бывает сложно обработать исключение.

Примеры нарушения базовой гарантии:
Главным способом предотвращением утечек памяти и других ресурсов является идиома RAII-классов (об этом подробнее ниже).

 Offtops:

1) Можно попросить оператор new не кидать исключение с помощью константы std::nothrow

RAII-class:

Пусть мы хотим открыть несколько файлов.

void read_some_file() {
    open_for_read("first_part.txt");
    open_for_read("second_part.txt");
    open_for_read("third_part.txt");
};

Причем гарантировать их закрытие в случает возникновения исключения.
Тогда давайте напишем такой код:
void read_some_file() {
    try {
        open_for_read("first_part.txt");
        open_for_read("second_part.txt");
        open_for_read("third_part.txt");
    } catch (...) {
        // Но мы не может понять какой файл открылся, какой нет. :(
    }
};
Тогда так:
void read_some_file() {
    size_t i = 0;
    string files[3] = {"first_part.txt", "second_part.txt", "third_part.txt" };
    try {
        for (; i < 3; ++i) {
            open_for_read(files[i]);
        }
    } catch (...) {
        for (size_t j = i; j != 0; --j) {
            close(files[j - 1]);
        }
    }
};

Итого код увеличился в два раза.

С помощью RAII-класса файловых дескрипторов reader , можно упростить код:

void read_some_file() {
    Reader reader1("first_part.txt");
    Reader reader2("second_part.txt");
    Reader reader3("third_part.txt");
};

Этот получился довольно простой и безопасный. Почему безопасный? Потому, что объект reader открывает файл в конструкторе и закрывает в деструкторе. И если возникнет исключение, то при раскрутке стека удаляться все локальные объекты, в том числе и файловые дескрипторы, закрывая файлы. Если же какой-то файл не успел открыться, то не успел и создаться объект отвечающий за него.

Это удобная идея получила название: RAII.

"Resource Acquision is Initialozation" или "Захват ресурса - это инициализация"- это идиома класса, который инкапсулирует управление каким-то ресурсом. Она значит, что объект этого класса, получает доступ к ресурсу и удерживает его в течении своей жизни, а потом этот ресурс высвобождается при уничтожении объекта.
В конструкторе он должен захватить ресурс(открыть файл, выделить файл и т. д.), а в десткрукторе освободить его(закрыть файл, освободить память и т. д.).

Также важно подумать, что должно происходить при копировании объекта, часто мы просто явно запрещаем это делать.

Что это дает?
1) Удобство кода: нам не приходится каждый раз в конце тела функции освобождать ресурсы. Мы просто заводим локальную переменную. И когда выполнение текущего блока будет завершено, локальные объекты RAII-классов удалятся и ресурсы освободятся автоматически.
2) Безопасность исключений: Если вызывается исключение, то нам гарантируется, что стек очиститься и все локальные объекты удаляться, а значит и освободятся ресурсы. Без RAII приходится в ручную освобождать все ресурсы. Причем нужно учитывать какие ресурсы успели захватить до исключения, а какие нет.
3) Часто важно освобождать ресурсы в обратном порядке, относительно того, как они были захвачены. Это как раз поддерживается раскруткой стека при удалении локальных объектов.

NB) Это идиома работает не только в С++, а любом языке с предсказуемым временем жизни объектов.


Вот небольшой пример RAII-класса, который будет управлять файлом.
Ресурсом является данные типа FILE (формат файла в Си).

class File {
public:
    File(char const *filename, char const *mode)
        : _file(fopen(filename, mode)) { } //захват ресурса

    ~File() {
        fclose(_file); // освобождение ресурса
    }

    File(File const &) = delete;
    File operator=(File const &) = delete;

private:
    FILE *_file;
}

RAII часто встречается стандартной библиотеке:
1) Smart pointers -- инкапсулируют несколько видов управления памятью
2) i/ofstream
3) Различные контейнеры

Best practice:

Вернемся к предыдущему примеру File.
Пусть в конструкторе есть код, который может сгенерировать исключение, тогда возникает проблема освобождения ресурса.
;
File::File(char const *filename, char const *mode)
    : _file(fopen(filename, mode)) {
        //код допускающий исключение
    }
Если в теле конструктора происходит исключение, то деструктор не вызовется, так как объект не считается созданным. Что делать?

Решение № 1
Написать try-catch
class File {
public:
    File(char const *filename, char const *mode)
    try
        : _file(fopen(filename, mode)) {
        //код допускающий исключение
    }
    catch (...) {
        destruct_obj();
    }

    ~File() {
        destruct_obj();
    }

private:
    void destruct_obj() {
        fclose(_file);
    }

    FILE * _file;
};
Минусы решения: можно лучше.
Решение № 2
Можно сделать отдельный подкласс, который хранит в себе ресурс.
class File {
    struct FileHandle {
        FileHandle(FILE *fh)
            : _fh(fh) { }

        ~FileHandle() {
            fclose(_fh);
        }

        FILE *_fh;
    }
    ;
public:
    File(char const * filename, char const * mode)
        : _file(fopen(filename, mode)) {
        // код допускающий исключения
    }

    ~File() = default;

private:
    FileHandle _file;
};
Теперь все тоже ок, так как при возникновении исключения, вызовутся деструкторы от все мемберов.
Минусы решения: можно еще лучше
Решение № 3 (Изящное)
Делегирующий конструктор.
class File
{
    File(FILE * file)
        : _file(file) { }

public:
    File(char const * filename, char const * mode)
        : File(fopen(filename, mode)) {
        // код допускающий исключения
    }

    ~File() {
        fclose(_file);
    }

private:
    FILE *_file;
};
Дело в том, что если мы в конструкторе вызываем другой конструктор, то после его выполнения объект считается созданным и уничтожится в нужное время.
