План:
1) основы механизма
2) тонкости использования
3) Практика: Зачем это все собственно нужно?
---------------------------------------------------------------------------------------
1) основы механизма

В ходе работы программы часто могут возникнуть ситуации, которые не вписываются в общий алгоритм, или которые просто не отражают саму логику программы, но их тоже приходиться учитывать. Это, например, нехватка памяти, неправильный вывод пользователя, ошибка работы с ресурсами и т. д. С другой стороны, четко определить, что стоит отделять от основной логики сложно. Поэтому дадим пока довольно общие определения, а как этим пользоваться на практике мы обсудим отдельно.

Исключение - это ситуация, которую МЫ сочли исключительной. Эти ситуации мы будет обрабатывать как-то особенно(отдельно от основной логики). Теперь нам нужно научиться выявлять, отслеживать и обрабатывать их.

Пусть мы пишем функцию, которая принимает три числа кладет в первое результат деления второго на третие.
void div(int &res, int a, int b) {
	res = a / b;
}

Пусть исключительно ситуация возникает тогда, когда b = 0. И мы хотим обработать это исключение так: положить в res просто значение a.

void div(int &res, int a, int b) {
	try {
		if (b == 0)
			throw b; // генерируем исключение
 // если исключения нет, то код работает в обычном режиме
		res = a / b;
	}
	catch(int a) { // ловим исключение
		res = a; // обрабатываем исключение
	}
}
NB) типом исключения называется тип объекта, которым передаем в throw. Тип исключения должен ясно описывать ситуацию, так как по типу выбирается обработчик.

Теперь рассмотрим используемы здесь конструкции:

try{} -- защищенный блок. Здесь мы пишем код, в которым будут ловиться исключения.
catch(){} -- блок перехвата исключений. Здесь буду ловиться исключения указанные в (), и обрабатывать инструкциями в {}
throw -- оператор инициализации исключения. Он генерирует исключение. (Обычно говорят, "бросает" или "выбрасывает" исключение)

блок try-catch - реализует обработку исключений. И имеет общий вид:
try {операторы защищенного блока}
// catch-блоки
catch() {обработчик}
...
catch() {обработчик}

Давайте еще раз как, это работает: если нет исключения, то все работает как обычно и catch-блоки не выполняются. Если происходит выброс исключения. Создается объект типа int со значением b, потом происходит выбор нужного обработчика, по типу этого объекта. Когда он нашелся, то выполняется соответствующий код обработки.

Теперь более подробно рассмотрим этот механизм:

общий вид catch-блока:
1) catch(Type) {обработчик исключения } // мы не используем генерируемый исключением объект.
2) catch(Type exception_variable) { обработчик исключения }
3) catch(...) {обработчик исключения} // мы ловим исключение с любым типом объекта

Что происходит когда мы генерируем исключение:
1) Создается статическая переменная со значением, заданным в операторе я throw. Она будет существовать до тех пор, пока исключение не будет обработано. Если переменная является объектом класса, то при создании вызовется конструктор копирования.
2) Прерывается выполнение защищенного try-блока(вызываются деструкторы временных объектов).
3) Выполняется поиск первого подходящего catch-блока

Как происходит поиск catch-блока:
Блоки рассматриваются в том порядке, в котором они указанны. По следующем критериям:
1) если тип, указанный в catch-блоке, совпадает с типом исключения или является ссылкой на этот тип.
2) класс, заданный в catch-блоке, является предком класса, заданного в throw, и наследование открытое (public).
3) указатель, заданый в операторе throw, может быть преобразован по стандартным правилам к указателю, заданному в catch-блоке.
4) в catch-блоке указанно многоточие

Если найдет нужный блок обработки, то выполняется его код, а остальные catch-блоки игнорируются.

NB) Так как поиск ведется последовательно, то нужно учитывать порядок catch-блоков (Например, catch(...) должен быть последним).

Если ни один catch-блок не подошел, то исключение не обработано, и поиск продолжается во внешнем коде (внешний блок или вызывающая функция).

Если пройдя по цепочке вызовов функции мы не нашли ни одного подходящего обработчика, то вызывается функция terminate(), которая вызывает abort().
NB) таком случае единственное, что мы модем сделать это написать свою функцию terminate() и зарегистрировать ее с помощью set_terminate.
Пример:
void my_terminate() { cout << "It's not a bug, it's a feature!"}
set_terminate(my_teminate);

Так же мы можем после обработки исключение в конце catch-блока написать оператор throw без параметров, тогда исключение считается обработанным не до конца. И происходит повторный выброс исключения: по статическому объекту исключения ищется еще один обработчик, который лежит выше по цепочке вызовов.
NB) при это следует заметить, что при повторном выбросе исключения рассматривается не параметр текущего catch-блока, а именно изначальный статический объект. Именно он скопируется в качестве параметра в следующий обработчик. Поэтому его этот статический объект живет пока его исключение не обработается полностью.
NB NB) Поэтому при приведении тип исключения не теряется.

Пусть мы бросили исключение Exception_heir, которое наследуется от Exception_base.
Следует различать catch(Exception_base exc) и  сatch(Exception_base &exc)
В первом случае exc -- это копия базовой части статического объекта типа Exception_heir.
А во втором сработает динамическое связывание, и мы может использовать виртуальные функции, чего не произойдет в первом случае, не смотря на идентичность статических типов exc.

Еще одним интересным моментом являются try-блоки в конструкторе. Конструктор - это очень важная часть класса, поэтому возможно ситуация, когда мы хотим обработать все исключения в нем. Наверно мы напишем так:
class St {
public:
	St(): member() {
		try {
		 // Constructor's code
		}
		{catchs}
	}
private:
	Member_type member;
}
Но заметим, что инициализация мемберов не находится внутри try-блока и не исключения возникшие в их конструкторах не поймаются. На самом деле тут есть особый синтаксис:
class St {
public:
	St() try: member() {
		 {
		 // Constructor's code
		}
		{catchs}
	}
private:
	Member_type member;
}

NB) Это называется функциональные try-блоки, то есть те, которые оборачивают все тело функции. Они есть и для обычных функций.
int main() try {
	//some code
}
{catchs}
///////////////////NOTE///////////////////////////////
У меня здесь почему-то не заработало, вот код:
#include <iostream>

class St {
public:
    St(int a, int b, int c) try: a(a), b(b), c(c) {
        throw 1;
    }
	catch(...) {
        std::cout << "error!";
    }
private:
    int a, b, c;
};

int main () {
    St a(1, 2, 3);
    return 0;
}
выводится строка "error!", но после этого дамп по памяти.
///////////////////NOTE///////////////////////////////

Также важно помнить, что если в конструкторе происходит исключение, то для него не вызовется деструктор, так объект еще не считается созданным.

NB) При генерации исключения параметр throw копируется в статическую переменную того же типа, что и СТАТИЧЕСКИЙ тип параметр. То есть такой код работать не бдует:

try {
	Exception_base *exc = new Exception_heir();
	throw exc;
} catch (Exception_heir *exc) {
	//some code
}

2) Best practice

Теперь, когда мы разобрались как работает механизм исключений, не плохо понять когда и где его лучше использовать.

Я опишу несколько ситуаций, которые покажут плохие и хорошие стороны исключений, и постараюсь подвести итог в конце.

Минусы:
1) Иногда бывает сложно понять, где происходит исключение и как его следует обработать. Эти ситуации возникают, когда нам приходится обрабатывать исключения, приходящие нам от внешнего кода.

 Во-первых без документации невозможно понять какие функции бросают исключения и какого типа.

 Во-вторых когда, мы узнаем тип исключения и какая функция его бросает, не всегда по типу исключения очевидно, как его следует обработать.

 real story: Бывает, что вы используете библиотеку с закрытым исходным кодом. И неожиданно одна из функции библиотеки кидает нам исключения типа int. И как его следует обработать ? :(

2) Не всегда мы знаем, как нужно обрабатывать ошибки, поэтому иногда больший смысл имеет просто логировать ошибки и просто продолжать исполнение кода, игнорируя ошибку. Это можно сделать catch(...), но если в нашем коде это распространенная ситуация, то механизм исключений избыточен.

Плюсы:
Исключения нужны там, где мы хотим, чтобы программа всегда работала корректно.
1) Например, мы увеличиваем вектор, и если у нас кончилась память для resize, то программа не падает и не убивает те данные, которые уже лежат в векторе.
2) Это механизм очень удобный, когда мы организовываем исключения в иерархии классов. Создав такую структуры мы при обработке, может обрабатывать как более общие ошибки, так и более специализированные.
Пример:
class StackException {};
class popOnEmpty(): public StackException {};
class pushOnFull(): public StackException {};

Причем сгенерировав исключение типа popOnEmpty()
Мы можем в разных обработчиках независимо выбирать: обработать как popOnEmpty или как StackException, так как тип исключения не теряется при повторной генерации этого исключения.

3)Полезно знать про стандартные исключения, которые также связанны наследованием.
|) std::ecxeption
	|      |
	v      v
||) std::bad_alloc, std::bad_cast, std::bad_typeid и т. д.

Подробнее можно почитать здесь: https://www.tutorialspoint.com/cplusplus/cpp_exceptions_handling.htm
http://en.cppreference.com/w/cpp/error/exception

4) Хорошим тоном является наследование от std::exception


Exception safety

Механизм исключений является довольно мощным инструментом. Но при этом не редко возникает проблемы с его читаемостью. Далеко не всегда очевидно откуда пришло исключение и как стоит его обрабатывать. Некоторые сравнивают эффект вызова исключений с эффектами от вызова goto.

Поэтому относительно работы исключений с объектами существуют Гарантии безопасности исключений (Exception safety).  Это ряд уровней безопасности, которые присваиваются методам класса. Они декларируют выполнение некоторого контракта относительно состояния объекта после выполнения операций над ним.

Уровни гарантий:

1) "No guarantees" - нет ни каких гарантий. После выполнения метода объект и данные в нем могут быть в любом состоянии. Предполагается, что объект больше не будет использоваться.
2) "Basic guarantees" - Гарантируется, что инварианты класса сохраняются и не происходит утечек памяти или других ресурсов.
3) "Strong guarantees" - Включает в себя базовую гарантию. А также требует, что в случае исключения объект остается в том, состоянии, в котором он был до выполнения операции. То есть либо операция прошла успешно, или она не повлияла на объект.
3) "Nothrow guarantees" - Кроме базовой гарантии, гарантируется, что исключения не возникают.


Теперь давайте более подробно:

Гарантия nothrow:

Она есть у очень небольшого количества функции: swap, vector::pop_back, операции с итераторами, Это гарантия очень важна, так как с ее помощью достигается строгая гарантия, когда мы производим необходимы операции на временном объекте, а потом просто делаем с ним swap.

Также важно, чтобы деструктор не пробросал исключений, иначе утечки неизбежны. Например, может возникнуть исключение и при очистки стека, возникает еще одно.

NB) Спецификатор noexcept (C++11) указывает компилятору, что выполняется гарантия nothrow. Это важно, для выбора конструктора копирования: перемещающего или нет, так как при перемещении бывает сложно обработать исключение.
Подробнее в статье про перемещение.

Примеры нарушения базовой гарантии:
Главным способом предотвращением утечек памяти и других ресурсов является идиома RAII-классов (об этом подробнее ниже).

 Offtops:

1) Можно попросить оператор new не кидать исключение с помощью константы std::nothrow

2) Можно указать какие исключение может кидать функция:
void f() throw(int, double)*
*что здесь можно написать:
1) throw() - функция не кидает исключения
2) throw(T1, T2, T3) - функция может кидать исключения T1, T2, T3
3) throw(...) - функция может кидать любые исключения
Это не используется в c++11, так как возникли какие-то проблемы, и по факту полезным оказался только throw().

RAII-class:
Основы:
"Resource Acquision is Initialozation" или "Захват ресурса - это инициализация"- это идиома класса, который инкапсулирует управление каким-то ресурсом. Она значит, что объект этого класса, получает доступ к ресурсу и удерживает его в течении своей жизни, а потом этот ресурс высвобождается.
В конструкторе он должен захватить ресурс(открыть файл, выделить файл и т. д.), а в десткрукторе освободить его(закрыть файл, освободить память и т. д.).

Также важно подумать, что должно происходить при копировании объекта, часто мы просто явно запрещаем это делать.

Что это дает?
1) Удобство кода: нам не приходится каждый раз в конце тела функции освобождать ресурсы. Мы просто заводим локальную переменную. И когда выполнение текущего блока будет завершено, локальные объекты RAII-классов удалятся и ресурсы освободятся автоматически.
2) Безопасность исключений: Если вызывается исключение, то нам гарантируется, что стек очиститься и все локальные объекты удаляться, а значит и освободятся ресурсы. Без RAII приходится в ручную освобождать все ресурсы. Причем нужно учитывать какие ресурсы успели захватить до исключения, а какие нет.
3) Часто важно освобождать ресурсы в обратном порядке, относительно того, как они были захвачены. Как раз раскрутка стека при удалении локальных объектов, это поддерживает.

NB) Это идиома работает не только в С++, а любом языке с предсказуемым временем жизни объектов.

Вот не большой пример RAII-класса, который будет управлять файлом.
Ресурсом является данные типа FILE (формат файла в Си).

class File {
public:
    File(char const *filename, char const *mode)
        : _file(fopen(filename, mode)) { } //захват ресурса

    ~File() {
        fclose(_file); // освобождение ресурса
    }

    File(File const &) = delete;
    File operator=(File const &) = delete;

private:
    FILE *_file;
}

Тонкие моменты в RAII:

1) Необрабатываемые исключения
Вот код:

int main {
    File("input.txt", "r");
    // здесь происходит исключение
    return 0;
}

Что не так?
Проблема в том, что не смотря на то, что мы использовали RAII-класс, ресурс не будет освобожден, так как удаление локальных файлов, гарантируется, только при перехвате исключения, иначе поведение зависит от реализации.
Поэтому main следует написать так:
int main() {
    try {
        File("input.txt", "r");
        // здесь происходит исключение
    }
    catch(...) {
        cerr << "Unexpected exception.\n";
    }
}
Теперь все ок.

2) Исключение в деструкторе. Но это проблема сама по себе.

3) Исключения в конструкторах.

Вернемся к предыдущему примеру File.
Пусть в конструкторе есть код, который может сгенерить исключение, тогда возникает проблема освобождения ресурса.
File::File(char const *filename, char const *mode)
    : _file(fopen(filename, mode)) {
        //код допускающий исключение
    }
Если в теле конструктора происходит исключение, то деструктор не вызовется, так как объект не считается созданным. Что делать?

Решение № 1
Написать try-catch
class File {
public:
    File(char const *filename, char const *mode)
    try
        : _file(fopen(filename, mode)) {
        //код допускающий исключение
    }
    catch (...) {
        destruct_obj();
    }

    ~File() {
        destruct_obj();
    }

private:
    void destruct_obj() {
        fclose(_file);
    }

    FILE * _file;
};
Минусы решения: можно лучше.
Решение № 2
Можно сделать отдельный подкласс, который хранит в себе ресурс.
class File {
    struct FileHandle {
        FileHandle(FILE *fh)
            : _fh(fh) { }

        ~FileHandle() {
            fclose(_fh);
        }

        FILE *_fh;
    }

public:
    File(char const * filename, char const * mode)
        : _file(fopen(filename, mode)) {
        // код допускающий исключения
    }

    ~File() = default;

private:
    FileHandle _file;
};
Теперь все тоже ок, так как при возникновении исключения, вызовутся деструкторы от все мемберов.
Минусы решения: можно еще лучше
Решение № 3 (Изящное)
Делегирующий конструктор.
class File
{
    File(FILE * file)
        : _file(file) { }

public:
    File(char const * filename, char const * mode)
        : File(fopen(filename, mode)) {
        // код допускающий исключения
    }

    ~File() {
        fclose(_file);
    }

private:
    FILE *_file;
};
Дело в том, что если мы в конструкторе вызываем другой конструктор, то после его выполнения объект считается созданным и уничтожится в нужное время.
