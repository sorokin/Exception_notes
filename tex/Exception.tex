\section{Exceptions}
\subsection{Введение}
В ходе написания программ, часто возникают случаи, когда нам приходится отвлекаться от написания основной логики. Нам нужно учитывать граничные случаи и ошибки, которые могут возникнуть как во внутреннем коде нашей программы, так и во внешнем коде. Это может быть: нехватка динамической памяти, неправильный ввод пользователя, ошибка с файловой системой и т. д.
Все это приходится продумывать, и иногда это может сильно увеличить количество кода и время его написания. Чтобы упростить обработку таких случаев существует паттерн исключений.

Исключение - это ситуация, которую МЫ сочли исключительной, и которую хотим отделить от основной логики программы. Естественно код обработки исключения мы тоже должны написать сами. Но компилятор помогает нам, генерировать дополнительную информации об исключении, отслеживать и подбирать необходимый код обработки в зависимости от исключения.

Пусть мы пишем функцию деления:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void div(int a, int b) {
    return a / b;
}
\end{minted}

Пусть исключительная ситуация возникает тогда, когда $b = 0$. И мы хотим сообщить об этом пользователю нашей функции.

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
class Division_by_zero() {
    int dividend
    string message;
    Division_by_zero(int &dividend, string const &message) :
        dividend(dividend), message(message) { }
};
\end{minted}

Мы объявили класс, объекты которого будут хранить в себе всю информации об исключении. Тип класса-исключения называется просто типом исключения.

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void div(int a, int b) {
    if (b == 0) // возникает исключительное состояние
        throw Division_by_zero(b, "in function div(int, int)"); // генерируем исключение.
    return a / b;
}
\end{minted}

Если возникает ситуация, когда нам передали в качестве делителя ноль, то мы создаем/генерируем/возбуждаем исключение. Это значит, что дальше не будет исполняться основная логика программы, пока не будет обработано исключение.

А так пользователь может обрабатывать исключение:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int main() {
    int n;
    cin >> n;
    try { // здесь указываем опрераторы, в которых мы хотим ловить исключения.
        for (int i = 0, a, b; i < n; ++i) {
            cin >> a >> b;
            cout << div(a, b);
        }
    } catch(Division_by_zero obj) { //здесь указываем тип исключения, которое мы хотим обработать
    // здесь обрабатываем исключение
        cout << obj.dividend << "by 0 " << obj.message();
    }
}
\end{minted}

Как только возникает попытка деления на ноль. генерируется исключение, в коде \mintinline{c++}{div(int, int)} оно не обрабатывается, поэтому выбрасывается во внешний код, где мы его ловим и выводим сообщение об ошибке.

Если исключения не возникает, то код отработает нужным образом: мы выведем результаты всех делений.

\subsection{Описание конструкций}
Теперь рассмотрим используемые здесь конструкции подробнее:

\mintinline{c++}{try{}} -- защищенный блок. Здесь мы пишем код, в котором мы хотим ловить и обрабатывать исключения.

\mintinline{c++}{catch(){}} -- блок перехвата исключений или блок обработки или обработчик. Здесь буду ловиться исключения, тип которых совпадает по определенным правилам с типом указанным в (), и обрабатывать инструкциями в \{\}

\mintinline{c++}{throw} -- оператор инициализации исключения. Он генерирует исключение. (Обычно говорят, "бросает"\ или "выбрасывает"\ исключение)

Теперь давай рассмотрим детали работы этого механизма.

Блок \mintinline{c++}{try-catch} - реализует обработку исключений. И имеет общий вид:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
try { /*операторы защищенного блока*/ }
// catch-блоки
catch() {/*код обработки*/}
...
catch() {/*код обработки*/}

\end{minted}
То есть обработчиков может быть несколько, каждый обрабатывает свой тип исключений.

Общий вид catch-блока:
\begin{itemize}
    \item
    \mintinline{c++}{catch(Type) { /*обработчик исключения*/ }}
    Мы не используем генерируемый исключением объект.
    \item
    \mintinline{c++}{catch(/*declaration exception_variable*/) { /*обработчик исключения*/ }}
    \item
    \mintinline{c++}{catch(...) { /*обработчик исключения*/ }}
    Мы ловим исключение с любым типом, но не можем получить к нему доступ.
\end{itemize}

Что происходит, когда мы генерируем исключение:
\begin{enumerate}
    \item
    Создается копия объекта переданного в оператор throw. Этот объект будет существовать до тех пор, пока исключение не будет обработано. Если тип объекта имеет конструктор копирования, то он будет вызван.
    \item
    Прерывается выполнение защищенного try-блока.
    \item
    Выполняется раскрутка стека, пока исключение не будет обработано.
\end{enumerate}

При раскрутке стека, вызываются деструкторы локальных переменных в обратном порядке их объявления. При разрушении всех локальных объектов текущей функции процесс продолжается в вызывающей функции. Раскрутка стека продолжается пока не будет найдем try-catch -блок. При нахождении try-catch-блока, проверяется, может ли исключение быть поймано одним их catch-блоков.

\subsection{Как ловится исключение?}

Catch-блоки проверяются в том порядке, в котором написаны. По следующим критериям:
\begin{enumerate}
    \item
    Eсли тип, указанный в catch-блоке, совпадает с типом исключения или является ссылкой на этот тип.
    \item
    Класс, заданный в catch-блоке, является предком класса, заданного в throw, и наследование открытое (public).
    \item
    Указатель, заданный в операторе throw, может быть преобразован по стандартным правилам к указателю, заданному в catch-блоке.
    \item
    В catch-блоке указанно многоточие
\end{enumerate}

Если найдет нужный catch-блок, то выполняется его код, остальные catch-блоки игнорируются, а выполнение продолжается после try...catch-блока и исключение считается обработанным. Если ни один catch-блок не подошел, процесс раскрутки стека продолжается.

\textcolor{red}{NB}) Так как поиск ведется последовательно, то нужно учитывать порядок catch-блоков (Например, catch(...) должен быть последним).

В некоторых случаях внутри catch-блока может быть необходимо не завершать раскрутку стека. Для этого существует специальная форма оператора throw без аргумента. Она означает проброс текущего исключения. Исключение все еще считается не обработанным.

\textcolor{red}{NB}) При это следует заметить, что при повторном выбросе исключения рассматривается не параметр текущего catch-блока, а именно изначальный статический объект. Именно он скопируется в качестве параметра в следующий обработчик. Поэтому его этот статический объект живет пока его исключение не обработается полностью. Поэтому при приведении тип исключения не теряется.

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
class Exception {
public:
    Exception(): value(0) { }
    int value;
};

void third() {
    throw Exception();
    std::cout << "end third\n";
}

void second() {
    try {
        third();
    }
    catch (Exception exc) {
        std::cout << "in second Exception-value = " << exc.value << std::endl;
        exc.value = 100;
        throw;
    }
    std::cout << "end second\n";
}

void first() {
    try {
        second();
    }
    catch (Exception exc) {
        std::cout << "in first Exception-value = " << exc.value << std::endl;
    }
    std::cout << "end first\n";
}

int main() {
    first();
    std::cout << "end main\n";
    return 0;
}
\end{minted}

\textbf{Вывод программы:} \\
in second() Exception-value = 0 \\
in first() Exception-value = 0 \\
end first \\
end main \\

\textcolor{red}{NB}) Также при наследовании классов исключений следует различать catch(type obj) и catch(type\& obj). В первом случае при входе в catch блок делается копия объекта-исключения. Во втором случае obj лишь ссылается на этот объект и копии не создается.

Пример:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
struct Exception_base {
    virtual char const* msg() const {
        return "base";
    }
};

struct Exception_derived : Exception_base {
    virtual char const* msg() const {
        return "derived";
    }
};

int f() {
    try {
        throw derived();
    }
    catch (base e) {
        std::cout << e.msg() << std::endl;
    }
}

int g() {
    try {
        throw derived();
    }
    catch (base const& e) {
        std::cout << e.msg() << std::endl;
    }
}
\end{minted}

В данном примере g() выводит <<derived>>, а функция f() выводит <<base>>, поскольку объект исключения был скопирован с базы объекта, который мы передали в оператор throw и новая копия имеет тип base.

\subsection{Function-try-block}

Часто мы хотим, чтобы все тело функции находилось в try-блоке. Тогда это try-блок называется функциональным. И для него есть отдельный синтаксис.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
int main() try {
    //main's body
}
catch (...) { }
\end{minted}

Здесь функциональные try-блоки являются синтаксическим сахаром, но есть ситуации когда без них не обойтись: обработка исключений в конструкторе.

Вот есть класс, котором мы хотим ловить и обрабатывать исключения.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
class St {
public:
    St(): member() {
        try {
            // Constructor's code
        }
        catch (...) { }
    }
private:
    Member_type member;
}
\end{minted}

Но заметим, что вызов конструкторов мемберов не находится внутри try-блока и исключения возникшие в их конструкторах не поймаются.
Поэтому мы используем здесь функциональный try-блок:

\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
class St {
public:
    St() try: member() {
        // Constructor's code
    }
    catch (...) {

    } // implicit throw
}
private:
    Member_type member;
}
\end{minted}

Но у функциональный try-блок в конструкторах, есть особенность: они всегда бросают исключение повторно.

Уничтожение объекта при исключении в конструкторе.

Также важно помнить, что если в конструкторе происходит исключение, то для него не вызовется деструктор, так объект еще не считается созданным.

\subsection{Best practice}
Часто исключений применяются для корректной работы с ресурсами. То есть если возникает исключение и владеем какими-то ресурсам, то в случае генерации исключения следует их освободить.

Например, мы пишем вектор, и мы хотим скопировать данные в другой участок памяти, чтобы скопировать вектор. При этом если во время копирование какого-то объекта возникнет исключение, то хорошо если уже созданные объекты будут разрушены.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
template <typename T>
void copy_construct(T* dist, T const * sourse, size_t size) {
    size_t i = 0;
    try {
        for (; i != size; ++i) {
            new (dist + i) T(sourse[i]);
        }
    }
    catch (...) { // если ошибка при копировании
        for (size_t j = i; j != 0; --j) {
            dist[j - 1].~T(); // вызовем деструкторы созданных объектов
        }
        throw;
    }
}
\end{minted}

Полезно знать про стандартные исключения, такие как  \mintinline{c++}{std::bad_alloc}, \mintinline{c++}{std::bad_cast}, \mintinline{c++}{std::bad_typeid} и т. д. Они также связанны наследованием и имеют общего предка \mintinline{c++}{std::exception}.

Подробнее можно почитать здесь: \\
\url{https://www.tutorialspoint.com/cplusplus/cpp_exceptions_handling.htm} \\
\url{http://en.cppreference.com/w/cpp/error/exception} \\

Хорошим тоном является наследование от \mintinline{c++}{std::exception}.

Когда мы организовываем исключения в иерархии классов, то получаем мощный механизм описания исключение и способов их обработки. Создав такую структуры мы можем обрабатывать как более общие ошибки, так и более специализированные.
Пример:
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
    class StackException {};
    class popOnEmpty(): public StackException {};
    class pushOnFull(): public StackException {};
\end{minted}
	Причем сгенерировав исключение типа popOnEmpty(), мы можем в разных обработчиках независимо выбирать: обработать как popOnEmpty или как StackException, так как тип исключения не теряется при повторной генерации этого исключения.

\subsection{Bad practice}
\begin{itemize}
\item 
Писать код бросающий исключения в catch-блоке. Это не всегда бывает просто.
\item 
Хотя если исключений не происходит, то по скорости выполнения программа не сильно упадет, но иногда нужно учитывать большой оверхед в случае возникновения и обработки исключения.
\end{itemize}

\subsection{std::terminate()}

Это функция, которая вызывается если у механизма исключений не получается корректно отработать, чтобы завершить программу.
Случаи когда она вызывается:
\begin{itemize}
\item Исключение брошено и не поймано ни одним catch-блоком, то есть пробрасывается вне main().
\item Исключение бросается во время обработки другого исключения. Это может произойти только в catch-блоке или деструкторе. А также в функциях, которые вызываются ими.
\item Если функция переданная в \mintinline{c++}{std::atexit} и \mintinline{c++}{std::at_quick_exit} бросит исключение.
\item Если функция нарушит гарантии noexcept specification. Например, если функция помеченная как noexcept бросит исключение.
\item При подобных и не только ошибках в потоках.
\end{itemize}

По умолчанию \mintinline{c++}{std::terminate()} вызвает \mintinline{c++}{std::abort()}, но можно это изменить, написав свою функцию \mintinline{c++}{my_terminate()} и зарегистрировать ее как терминальную.
\begin{minted}[linenos, frame=lines, framesep=2mm, tabsize = 4, breaklines]{c++}
void my_terminate() {
    cout << "It's not a bug, it's a feature!";
}
/**/
set_terminate(my_teminate);
\end{minted}
